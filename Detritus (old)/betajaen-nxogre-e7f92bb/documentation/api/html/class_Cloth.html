<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <meta http-equiv="Content-type" content="text/html; charset=utf-8">
  <title>NxOgre API - Cloth</title>
  <style type="text/css" media="screen">
  body,	html, #W, #N {margin:0;padding:0;height:100%;background-color:#181818;}
  #W {background-color:black;height:100%;background-color:#181818;}
  #C {float:right;width:80%;background-color:white;}
  #N {float:left;width:20%;background-color:#181818;}
  #F {clear:both;}
  * html #F {height:1px;}
  h1,h2,h3,h4,h5,h6{font-family:sans-serif;font-weight:normal;color:#333;letter-spacing:-0.05em}
  #N {font-family:sans-serif;font-size:0.9em;}
  #N h1, #N h2, #N h3, #N .enums{margin:0;padding:0;color:#ccc;text-decoration:none;}
  #N{color:white;}
  #N h1{background-color:#333;font-size:18pt;}
  #N h2, #N .enums{background-color:#222;display:block;font-size:16pt;}
  #N h3{padding-left:0.5em}
  #N ul{list-style:none;margin:0;padding:0 0 0 0.1em;}
  #N ul li{margin:0;}
  #N ul li a{color:#ccc;text-decoration:none;display:block;padding:0.25em 0 0.25em 0.5em;}
  #N ul li a:hover, #N .enums:hover{background-color:#ccc;color:#181818}
  #N ul li.this {padding:0.25em 0 0.25em 0.5em;}
  #N .this {background-color:white;color:black;}
  #C div{padding:1em;color:black;}
  .t h1 {margin:0 0 0.1em 0;padding:0;color:#555;font-size:36pt;border-bottom:2px dashed #ccc;}
  .t h2.source{font-size: smaller;position:absolute;top:0;right:0;text-align:right;padding:1em;}
  .t h3{}
  .t p.d{color:#333;line-height:1.5;margin:0;padding:0.35em 0 0.35em 0.5em;border-left:4px solid #ddd;}
  .t pre{padding-left:1em;}
  .t ul.short {list-style:none;padding:0;margin:0;padding-bottom:1em;border-bottom:2px dashed #aaa;}
  .t ul.short li {padding-right:0.5em;margin-bottom:1em;display:inline;list-style:none;list-style-type:none;}
  .t ul.short li a {text-decoration:none;}
  .t ul.short li a:hover {text-decoration:underline;}
  .t ul.short li a.m {color:Brown;font-weight:bolder;}
  .t ul.short li a.v {color:ForestGreen;}
  .t pre {overflow:auto;width:95%;}
  .t pre code {color:#444;}
  .t pre code span.cpptype {color:blue;}
  .t pre code span.cppblock {color:black;font-weight:bolder;}
  .t pre code span.cpppreprocessor {color:purple;font-weight:bolder;}
  .t pre code b {color:green;}
  .t h2.method {margin:0;padding:0;color:red;}
  .t div.method {padding:0 0 0 2em;margin:0;}
  .t div.method p{padding:0 0 1em 0;margin:0;font-family:Georgia;font-size:11.5pt;line-height:1.3;}
  .t table {border:1px solid #999;}
  .t table tr th {text-align:left;border-bottom:1px solid #999}
  .t table tr th:first-child{border-right:1px solid #999;}
  .t table tr td:first-child{font-family:monospace;border-right:1px solid #999;font-weight:bolder;}
  .t table tr td:first-child i{font-style:normal;font-weight:normal;color:#333;}
  span.math{letter-spacing:-1px;font-size:larger;font-weight:bolder;word-spacing:-0.1em;padding:0 0.1em 0 0.1em;}
  .t p.sm {font-size:smaller;}
  
</style>
</head>
<body>
  <div id="W">
    <div id="N">
      <h1>NxOgre API</h1>
      <a href="enums.html" class="enums">Enums</a><h2>Classes</h2><ul><li><a href="class_Actor.html">Actor</a></li><li><a href="class_ActorMachinePart.html">ActorMachinePart</a></li><li><a href="class_Archive.html">Archive</a></li><li><a href="class_BoundsTclass VecType.html">BoundsT<class VecType></a></li><li><a href="class_Box.html">Box</a></li><li><a href="class_Callback.html">Callback</a></li><li><a href="class_Capsule.html">Capsule</a></li><li class="this">Cloth</li><li><a href="class_ClothDescription.html">ClothDescription</a></li><li><a href="class_Compartment.html">Compartment</a></li><li><a href="class_CompartmentDescription.html">CompartmentDescription</a></li><li><a href="class_ContactPair.html">ContactPair</a></li><li><a href="class_Convex.html">Convex</a></li><li><a href="class_D6Joint.html">D6Joint</a></li><li><a href="class_D6JointDescription.html">D6JointDescription</a></li><li><a href="class_EntityReport.html">EntityReport</a></li><li><a href="class_Error.html">Error</a></li><li><a href="class_ErrorStream.html">ErrorStream</a></li><li><a href="class_FileArchive.html">FileArchive</a></li><li><a href="class_FileResource.html">FileResource</a></li><li><a href="class_FileResourceProtocol.html">FileResourceProtocol</a></li><li><a href="class_FixedJoint.html">FixedJoint</a></li><li><a href="class_FixedSceneTimer.html">FixedSceneTimer</a></li><li><a href="class_Fluid.html">Fluid</a></li><li><a href="class_RigidBody.html">RigidBody</a></li><li><a href="class_World.html">World</a></li></ul><h2>Pages</h2><ul><li><a href="README.html">README</a></li></ul>
    </div>
    <div id="C">
  		<div class="t">
<h1>Cloth</h1><h2 class="source">NxOgreCloth.h</h2>
<div class="method">	<p class="c"><a href="class_Cloth.html">Cloth</a> is an instance of a <b>Mesh</b> containg a <a href="class_Cloth.html">Cloth</a>.</p>

	<p class="c">Generally speaking a <a href="class_Cloth.html">Cloth</a> is &#8220;rendered&#8221; through a RenderSystem which<br />may or may not have a specific function for creating and setting up<br />the cloth for you &#8212; You should refer to that.</p>
</div><h3>Methods and Variables</h3>
<ul class="short">
<li><a href="#addDirectedForceAtPos" class="m">addDirectedForceAtPos</a></li>
<li><a href="#addForceAtPos" class="m">addForceAtPos</a></li>
<li><a href="#addForceAtVertex" class="m">addForceAtVertex</a></li>
<li><a href="#attachToCollidingShapes" class="m">attachToCollidingShapes</a></li>
<li><a href="#attachToCore" class="m">attachToCore</a></li>
<li><a href="#attachToShape" class="m">attachToShape</a></li>
<li><a href="#attachVertexToGlobalPosition" class="m">attachVertexToGlobalPosition</a></li>
<li><a href="#attachVertexToShape" class="m">attachVertexToShape</a></li>
<li><a href="#detachFromShape" class="m">detachFromShape</a></li>
<li><a href="#dominateVertex" class="m">dominateVertex</a></li>
<li><a href="#freeVertex" class="m">freeVertex</a></li>
<li><a href="#getAttachmentResponseCoefficient" class="m">getAttachmentResponseCoefficient</a></li>
<li><a href="#getAttachmentTearFactor" class="m">getAttachmentTearFactor</a></li>
<li><a href="#getBendingStiffness" class="m">getBendingStiffness</a></li>
<li><a href="#getCollisionResponseCoefficient" class="m">getCollisionResponseCoefficient</a></li>
<li><a href="#getDampingCoefficient" class="m">getDampingCoefficient</a></li>
<li><a href="#getDensity" class="m">getDensity</a></li>
<li><a href="#getExternalAcceleration" class="m">getExternalAcceleration</a></li>
<li><a href="#getFlags" class="m">getFlags</a></li>
<li><a href="#getForceFieldMaterial" class="m">getForceFieldMaterial</a></li>
<li><a href="#getFriction" class="m">getFriction</a></li>
<li><a href="#getFromFluidResponseCoefficient" class="m">getFromFluidResponseCoefficient</a></li>
<li><a href="#getGroup" class="m">getGroup</a></li>
<li><a href="#getGroupsMask" class="m">getGroupsMask</a></li>
<li><a href="#getMesh" class="m">getMesh</a></li>
<li><a href="#getMinAdhereVelocity" class="m">getMinAdhereVelocity</a></li>
<li><a href="#getName" class="m">getName</a></li>
<li><a href="#getNumberOfParticles" class="m">getNumberOfParticles</a></li>
<li><a href="#getPPUTime" class="m">getPPUTime</a></li>
<li><a href="#getPhysXCloth" class="m">getPhysXCloth</a></li>
<li><a href="#getPhysXMeshData" class="m">getPhysXMeshData</a></li>
<li><a href="#getPosition" class="m">getPosition</a></li>
<li><a href="#getPositions" class="m">getPositions</a></li>
<li><a href="#getPressure" class="m">getPressure</a></li>
<li><a href="#getRelativeGridSpacing" class="m">getRelativeGridSpacing</a></li>
<li><a href="#getRenderable" class="m">getRenderable</a></li>
<li><a href="#getScene" class="m">getScene</a></li>
<li><a href="#getSolverIterations" class="m">getSolverIterations</a></li>
<li><a href="#getStretchingStiffness" class="m">getStretchingStiffness</a></li>
<li><a href="#getTearFactor" class="m">getTearFactor</a></li>
<li><a href="#getThickness" class="m">getThickness</a></li>
<li><a href="#getToFluidResponseCoefficient" class="m">getToFluidResponseCoefficient</a></li>
<li><a href="#getVelocities" class="m">getVelocities</a></li>
<li><a href="#getVelocity" class="m">getVelocity</a></li>
<li><a href="#getVertexAttachmentPosition" class="m">getVertexAttachmentPosition</a></li>
<li><a href="#getVertexAttachmentShape" class="m">getVertexAttachmentShape</a></li>
<li><a href="#getVertexAttachmentStatus" class="m">getVertexAttachmentStatus</a></li>
<li><a href="#getWindAcceleration" class="m">getWindAcceleration</a></li>
<li><a href="#getWorldBounds" class="m">getWorldBounds</a></li>
<li><a href="#overlapAABBTriangles" class="m">overlapAABBTriangles</a></li>
<li><a href="#putToSleep" class="m">putToSleep</a></li>
<li><a href="#raycast" class="m">raycast</a></li>
<li><a href="#setAttachmentResponseCoefficient" class="m">setAttachmentResponseCoefficient</a></li>
<li><a href="#setAttachmentTearFactor" class="m">setAttachmentTearFactor</a></li>
<li><a href="#setBendingStiffness" class="m">setBendingStiffness</a></li>
<li><a href="#setCollisionResponseCoefficient" class="m">setCollisionResponseCoefficient</a></li>
<li><a href="#setDampingCoefficient" class="m">setDampingCoefficient</a></li>
<li><a href="#setExternalAcceleration" class="m">setExternalAcceleration</a></li>
<li><a href="#setFlags" class="m">setFlags</a></li>
<li><a href="#setForceFieldMaterial" class="m">setForceFieldMaterial</a></li>
<li><a href="#setFriction" class="m">setFriction</a></li>
<li><a href="#setFromFluidResponseCoefficient" class="m">setFromFluidResponseCoefficient</a></li>
<li><a href="#setGroupsMask" class="m">setGroupsMask</a></li>
<li><a href="#setMinAdhereVelocity" class="m">setMinAdhereVelocity</a></li>
<li><a href="#setName" class="m">setName</a></li>
<li><a href="#setPosition" class="m">setPosition</a></li>
<li><a href="#setPositions" class="m">setPositions</a></li>
<li><a href="#setPressure" class="m">setPressure</a></li>
<li><a href="#setSolverIterations" class="m">setSolverIterations</a></li>
<li><a href="#setStretchingStiffness" class="m">setStretchingStiffness</a></li>
<li><a href="#setTearFactor" class="m">setTearFactor</a></li>
<li><a href="#setThickness" class="m">setThickness</a></li>
<li><a href="#setToFluidResponseCoefficient" class="m">setToFluidResponseCoefficient</a></li>
<li><a href="#setVelocities" class="m">setVelocities</a></li>
<li><a href="#setVelocity" class="m">setVelocity</a></li>
<li><a href="#setWindAcceleration" class="m">setWindAcceleration</a></li>
<li><a href="#tearVertex" class="m">tearVertex</a></li>
<li><a href="#wakeUp" class="m">wakeUp</a></li>
</ul><h2 class="method destructor"><a name='Cloth'></a>Cloth</h2>
<div class="method">	<h3 class="t">Traits</h3>

	<ul>
		<li>Private function.</li>
	</ul>

</div><h2 class="method function"><a name='addDirectedForceAtPos'></a>addDirectedForceAtPos</h2>
<div class="method">	<p class="c">Applies a radial force (or impulse) at a particular position. All vertices<br />within radius will be affected with a quadratic drop-off.</p>

	<p class="c">Because forces are reset at the end of every timestep, you can maintain<br />a total external force on an object by calling this once every frame.</p>

	<p class="c">Enums::ForceMode determines if the force is to be conventional or impulsive.</p>


	<p class="n"><b>Note</b> &#8212; Supported modes are ForceMode_Force, ForceMode_Impulse, ForceMode_Acceleration, ForceMode_Velocity)</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>const Vec3& <i>position</i> </td>
			<td> Position to apply force at.</td>
		</tr>
		<tr>
			<td>const Vec3& <i>force</i> </td>
			<td> Force/impulse to add, defined in the global frame.</td>
		</tr>
		<tr>
			<td>Real <i>magnitude</i> </td>
			<td> Magnitude of the force/impulse to apply.</td>
		</tr>
		<tr>
			<td>Real <i>radius</i> </td>
			<td> The sphere radius in which particles will be affected. <b>Range:</b> position vector</td>
		</tr>
		<tr>
			<td>Enums::ForceMode <i>mode</i> </td>
			<td> mode The mode to use when applying the force/impulse. Default: Enums::ForceMode_Force</td>
		</tr>
		<tr>

		</tr>
	</table>

</div><h2 class="method function"><a name='addForceAtPos'></a>addForceAtPos</h2>
<div class="method">	<p class="c">Applies a radial force (or impulse) at a particular position. All vertices<br />within radius will be affected with a quadratic drop-off.</p>

	<p class="c">Because forces are reset at the end of every timestep, you can maintain<br />a total external force on an object by calling this once every frame.</p>

	<p class="c">Enums::ForceMode determines if the force is to be conventional or impulsive.</p>


	<p class="n"><b>Note</b> &#8212; Supported modes are ForceMode_Force, ForceMode_Impulse, ForceMode_Acceleration, ForceMode_Velocity)</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>const Vec3& <i>position</i> </td>
			<td> Position to apply force at.</td>
		</tr>
		<tr>
			<td>Real <i>magnitude</i> </td>
			<td> Magnitude of the force/impulse to apply.</td>
		</tr>
		<tr>
			<td>Real <i>radius</i> </td>
			<td> The sphere radius in which particles will be affected. <b>Range:</b> position vector</td>
		</tr>
		<tr>
			<td>Enums::ForceMode <i>mode</i> </td>
			<td> mode The mode to use when applying the force/impulse. Default: Enums::ForceMode_Force</td>
		</tr>
		<tr>

		</tr>
	</table>

</div><h2 class="method function"><a name='addForceAtVertex'></a>addForceAtVertex</h2>
<div class="method">	<p class="c">Applies a force (or impulse) defined in the global coordinate frame, to a particular<br />vertex of the cloth.</p>

	<p class="c">Because forces are reset at the end of every timestep, you can maintain<br />a total external force on an object by calling this once every frame.</p>

	<p class="c">Enums::ForceMode determines if the force is to be conventional or impulsive.</p>


	<p class="n"><b>Note</b> &#8212; Supported modes are ForceMode_Force, ForceMode_Impulse, ForceMode_Acceleration, ForceMode_Velocity)</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>const Vec3& <i>force</i> </td>
			<td> Force/impulse to add, defined in the global frame.</td>
		</tr>
		<tr>
			<td>unsigned int <i>vertexId</i> </td>
			<td> Number of the vertex to add the force at.</td>
		</tr>
		<tr>
			<td>Enums::ForceMode <i>mode</i> </td>
			<td> mode The mode to use when applying the force/impulse. Default: Enums::ForceMode_Force</td>
		</tr>
		<tr>

		</tr>
	</table>

</div><h2 class="method advanc"><a name='advance'></a>advance</h2>
<div class="method">	<p class="c">Time advancing function, called by TimeController</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>float <i>deltaTime</i> </td>
			<td> Time passed</td>
		</tr>
		<tr>
			<td>const Enums::Priority& priority </td>
			<td> Priority of the cloth</td>
		</tr>
	</table>

	<h3 class="t">Traits</h3>

	<ul>
		<li>Private function.</li>
	</ul>

</div><h2 class="method function"><a name='attachToCollidingShapes'></a>attachToCollidingShapes</h2>
<div class="method">	<p class="c">Attaches the cloth to all shapes, currently colliding.</p>
	<p class="n"><b>Note</b> &#8212; Cube, Sphere, <a href="class_Capsule.html">Capsule</a> and <a href="class_Convex.html">Convex</a> are only valid shapes to attach to.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>unsigned int <i>attachmentFlags</i> </td>
			<td> Attachment flags</td>
		</tr>
	</table>

<h3 class="e">Example</h3>
<pre><code>   cloth->attachToCollidingShapes(Enums::<b>Cloth</b>AttachmentFlags_Twoway);
   Enums::<b>Cloth</b>AttachmentFlags
</code></pre>
</div><h2 class="method function"><a name='attachToCore'></a>attachToCore</h2>
<div class="method">	<p class="c">After this call, the cloth is infinitely stiff between collisions and simply<br />moves with the actor. At impacts with an impact impulse greater than impulseThreshold,<br />the cloth is plastically deformed. Thus, a cloth with a core behaves like a piece of metal.</p>

	<p class="c">The core actor&#8217;s geometry is adjusted automatically. Its size also depends on the<br />cloth thickness. Thus, it is recommended to choose small values for the thickness.<br />At impacts, colliding objects are moved closer to the cloth by the value provided in<br />penetrationDepth which causes a more dramatic collision result.</p>

	<p class="c">The core actor must have at least one shape, and currently supported shapes are<br />spheres, capsules, boxes and compounds of spheres.<br />It is recommended to specify the density rather than the mass of the core body.<br />This way the mass and inertia tensor are updated when the core deforms.</p>

	<p class="c">The maximal deviation of cloth particles from their initial positions<br />(modulo the global rigid body transforms translation and rotation) can be<br />specified via the parameter maxDeformationDistance. Setting this parameter to<br />zero means that the deformation is not limited.</p>


	<p class="n"><b>Note</b> &#8212; * Call this function only once right after the cloth is created. Turning cloth into metal and vice versa during the simulation is not recommended.
	<ul>
		<li>This feature is well suited for volumetric objects like barrels. It cannot handle two dimensional flat pieces well.</li>
	</ul></p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>RigidBody* <i>rigidBody</i> </td>
			<td> The core actor to attach the cloth to.</td>
		</tr>
		<tr>
			<td>Real <i>impulseThreshold</i> </td>
			<td> Threshold for when deformation is allowed.</td>
		</tr>
		<tr>
			<td>Real <i>penetrationDepth</i> </td>
			<td> Amount by which colliding objects are brought closer to the cloth.</td>
		</tr>
		<tr>
			<td>Real <i>maxDeformationDistance</i> </td>
			<td> Maximum deviation of cloth particles from initial position.</td>
		</tr>
		<tr>

		</tr>
	</table>

</div><h2 class="method function"><a name='attachToShape'></a>attachToShape</h2>
<div class="method">	<p class="c">Attaches the cloth to a shape. All cloth points currently inside the shape are attached.</p>
	<p class="n"><b>Note</b> &#8212; Cube, Sphere, <a href="class_Capsule.html">Capsule</a> and <a href="class_Convex.html">Convex</a> are only valid shapes to attach to.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>Shape* <i>shape</i> </td>
			<td> Shape for which the cloth to be attached to.</td>
		</tr>
		<tr>
			<td>unsigned int <i>attachmentFlags</i> </td>
			<td> Attachment flags</td>
		</tr>
	</table>

<h3 class="e">Example</h3>
<pre><code>   cloth->attachToShape(box_shape, Enums::<b>Cloth</b>AttachmentFlags_Twoway | <b>Cloth</b>AttachmentFlags_Tearable);
   Enums::<b>Cloth</b>AttachmentFlags
</code></pre>
</div><h2 class="method function"><a name='attachVertexToGlobalPosition'></a>attachVertexToGlobalPosition</h2>
<div class="method">	<p class="c">Attaches a cloth vertex to a position in world space</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>unsigned int <i>vertexID</i> </td>
			<td> Vertex ID to attach</td>
		</tr>
		<tr>
			<td>const Vec3& <i>globalPos</i> </td>
			<td> Global position in world space.</td>
		</tr>
	</table>

<h3 class="e">Example</h3>
<pre><code>   cloth->attachVertexToGlobalPosition(33, Vec3(0, 10, 0));
</code></pre>
</div><h2 class="method function"><a name='attachVertexToShape'></a>attachVertexToShape</h2>
<div class="method">	<p class="c">Attaches a cloth vertex to a local position within a shape.</p>
	<p class="n"><b>Note</b> &#8212; Cube, Sphere, <a href="class_Capsule.html">Capsule</a> and <a href="class_Convex.html">Convex</a> are only valid shapes to attach to.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>unsigned int <i>vertexID</i> </td>
			<td> Vertex ID to attach</td>
		</tr>
		<tr>
			<td>Shape* <i>shape</i> </td>
			<td> Shape to attach the verex to</td>
		</tr>
		<tr>
			<td>const Vec3& <i>localPos</i> </td>
			<td> Local position relative to the pose of the shape</td>
		</tr>
		<tr>
			<td>unsigned int <i>attachmentFlags</i> </td>
			<td> Attachment flags</td>
		</tr>
	</table>

<h3 class="e">Example</h3>
<pre><code>   cloth->attachVertexToShape(33, box_shape, Vec3(0, 1, 0), Enums::<b>Cloth</b>AttachmentFlags_Twoway | <b>Cloth</b>AttachmentFlags_Tearable);
   Enums::<b>Cloth</b>AttachmentFlags
</code></pre>
</div><h2 class="method function"><a name='detachFromShape'></a>detachFromShape</h2>
<div class="method">	<p class="c">Detaches the cloth from a shape it has been attached to before.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>Shape* <i>shape</i> </td>
			<td> Shape to detach the cloth from.</td>
		</tr>
	</table>

</div><h2 class="method function"><a name='dominateVertex'></a>dominateVertex</h2>
<div class="method">	<p class="c">Changes the weight of a vertex in the cloth solver for a period of time.</p>

	<p class="c">If this method is called for some vertex, the cloth solver will, during a time<br />period of length expirationTime, assign a different weight to the vertex<br />while internal cloth constraints (i.e. bending & stretching) are being resolved.</p>

	<p class="c">With a high dominanceWeight, the modified vertex will force neighboring vertices<br />to strongly accommodate their positions while its own is kept fairly constant.<br />The reverse holds for smaller dominanceWeights.</p>

	<p class="c">Using a dominanceWeight of +infinity has a similar effect as temporarily attaching<br />the vertex to a global position. However, unlike using attachments, the velocity<br />of the vertex is kept intact when using this method.</p>


	<p class="n"><b>Note</b> &#8212; * The current implementation will not support the full range of dominanceWeights. All dominanceWeights > 0.0 are treated equally as being +infinity.
	<ul>
		<li>An expiration time of 0.0 is legal and will result in dominance being applied throughout one substep before being discarded immediately.</li>
		<li>Having a large number of vertices dominant at once may result in a performance penalty.</li>
	</ul></p>


	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>unsigned int <i>vertexId</i> </td>
			<td> Index of the vertex</td>
		</tr>
		<tr>
			<td>Real <i>expirationTime</i> </td>
			<td> Time period where dominance will be active for this vertex.</td>
		</tr>
		<tr>
			<td>Real <i>dominanceWeight</i> </td>
			<td> Dominance weight for this vertex.</td>
		</tr>
	</table>

</div><h2 class="method function"><a name='freeVertex'></a>freeVertex</h2>
<div class="method">	<p class="c">Frees a previously attached cloth point.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>unsigned int <i>vertexId</i> </td>
			<td> Vertex to free</td>
		</tr>
	</table>

</div><h2 class="method function"><a name='getAttachmentResponseCoefficient'></a>getAttachmentResponseCoefficient</h2>
<div class="method">	<p class="c">Gets the attachment response coefficient</p>
	<h3>Return</h3>

	<p class="r"><b>Real</b> &#8212; Response coefficient.</p>

</div><h2 class="method function"><a name='getAttachmentTearFactor'></a>getAttachmentTearFactor</h2>
<div class="method">	<p class="c">Retrieves the attachment cloth tear factor.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td><b>Real</b> </td>
			<td> attachment tear factor.</td>
		</tr>
	</table>

	<h3 class="s">See</h3>

	<p class="s"><a href="class_Cloth.html">Cloth</a>::setAttachmentTearFactor</p>

</div><h2 class="method function"><a name='getBendingStiffness'></a>getBendingStiffness</h2>
<div class="method">	<p class="c">Gets the cloth bending stiffness.</p>
	<h3>Return</h3>

	<p class="r">Bending stiffness of the <a href="class_Cloth.html">Cloth</a></p>

	<h3 class="s">See</h3>

	<p class="s"><a href="class_Cloth.html">Cloth</a>::setBendingStiffness</p>

</div><h2 class="method function"><a name='getCollisionResponseCoefficient'></a>getCollisionResponseCoefficient</h2>
<div class="method">	<p class="c">Retrieves the collision response coefficient.</p>
	<h3>Return</h3>

	<p class="r"><b>Real</b> &#8212; response coefficient</p>

</div><h2 class="method function"><a name='getDampingCoefficient'></a>getDampingCoefficient</h2>
<div class="method">	<p class="c">Gets the damping coefficient.</p>
	<h3>Return</h3>

	<p class="r"><b>Real</b> &#8212; Damping coefficient</p>

</div><h2 class="method function"><a name='getDensity'></a>getDensity</h2>
<div class="method">	<p class="c">Gets the cloth density.</p>
	<h3>Return</h3>

	<p class="r"><b>Real</b> &#8212; <a href="class_Cloth.html">Cloth</a> density.</p>

</div><h2 class="method function"><a name='getExternalAcceleration'></a>getExternalAcceleration</h2>
<div class="method">	<p class="c">Retrieves the external acceleration which affects all non attached particles of the cloth.</p>
	<h3>Return</h3>

	<p class="r"><b>Vec3</b> &#8212; Acceleration vector (<code>unit length / s^2</code>).</p>

</div><h2 class="method function"><a name='getFlags'></a>getFlags</h2>
<div class="method">	<p class="c">Retrieves the flags.</p>
	<h3>Return</h3>

	<p class="r"><b>unsigned int</b> &#8212; The cloth flags.</p>

</div><h2 class="method function"><a name='getForceFieldMaterial'></a>getForceFieldMaterial</h2>
<div class="method">	<p class="c">Retrieves the actor&#8217;s force field material index</p>
	<h3>Return</h3>

	<p class="r"><b>MaterialIdentifier</b> &#8212; Forcefield material.</p>

</div><h2 class="method function"><a name='getFriction'></a>getFriction</h2>
<div class="method">	<p class="c">Gets the cloth friction coefficient.</p>
	<h3>Return</h3>

	<p class="r"><b>Real</b> &#8212; Friction coefficient</p>

	<h3 class="s">See</h3>

	<p class="s"><a href="class_Cloth.html">Cloth</a>::setFriction</p>

</div><h2 class="method function"><a name='getFromFluidResponseCoefficient'></a>getFromFluidResponseCoefficient</h2>
<div class="method">	<p class="c">Gets the response coefficient for collisions from fluids to this cloth</p>
	<h3>Return</h3>

	<p class="r"><b>Real</b> &#8212; Response coefficient.</p>

</div><h2 class="method function"><a name='getGroup'></a>getGroup</h2>
<div class="method">	<p class="c">Gets the collision group the cloth belongs to.</p>
	<h3>Return</h3>

	<p class="r"><b>GroupIdentifier</b> &#8212; Collision group for the cloth</p>

</div><h2 class="method function"><a name='getGroupsMask'></a>getGroupsMask</h2>
<div class="method">	<p class="c">Gets the collision mask for filtering</p>
	<h3>Return</h3>

	<p class="r"><b>int4</b> &#8212; The group mask for the cloth.</p>

</div><h2 class="method function"><a name='getMesh'></a>getMesh</h2>
<div class="method">	<p class="c">Get the mesh that the cloth is using.</p>
	<p class="n"><b>Note</b> &#8212; This mesh is owned by the MeshManager, and may be shared by other cloths, do<br />not delete the pointer or change the mesh.</p>
	<h3>Return</h3>

	<p class="r"><b>Mesh</b> * &#8212; Mesh that the cloth is using.</p>

	<h3 class="s">See</h3>

	<p class="s">Mesh</p>

</div><h2 class="method function"><a name='getMinAdhereVelocity'></a>getMinAdhereVelocity</h2>
<div class="method">	<p class="c">If the Enums::<a href="class_Cloth.html">Cloth</a>Flags_Adhere flag is set the cloth moves partially in the frame of the attached rigid body.</p>

	<p class="c">This feature is useful when the cloth is attached to a fast moving character.<br />In that case the cloth adheres to the shape it is attached to while only<br />velocities below the parameter minAdhereVelocity are used for secondary effects.</p>
	<h3>Return</h3>

	<p class="r"><b>Real</b> &#8212; The minimal velocity for cloth to adhere (<code>unit length / s</code>)</p>

	<h3 class="s">See</h3>

	<p class="s"><a href="class_Cloth.html">Cloth</a>::setMinAdhereVelocity</p>

</div><h2 class="method function"><a name='getName'></a>getName</h2>
<div class="method">	<p class="c">Get the name of the cloth or BLANK_STRING</p>
	<h3>Return</h3>

	<p class="r"><b>String</b> &#8212; The name of the cloth.</p>

</div><h2 class="method function"><a name='getNumberOfParticles'></a>getNumberOfParticles</h2>
<div class="method">	<p class="c">Gets the number of cloth particles.</p>
	<h3>Return</h3>

	<p class="r"><b>unsigned int</b> &#8212; The number of particles in the cloth.</p>

</div><h2 class="method function"><a name='getPPUTime'></a>getPPUTime</h2>
<div class="method">	<p class="c">Get the <span class="caps">PPU</span> simulation time.</p>
	<h3>Return</h3>

	<p class="r"><b>unsigned int</b> &#8212; Simulation time.</p>

</div><h2 class="method function"><a name='getPhysXCloth'></a>getPhysXCloth</h2>
<div class="method">	<p class="c">Get the NxCloth instance.</p>
	<h3>Return</h3>

	<p class="r"><b>NxCloth</b> * &#8212; NxCloth instance of this <a href="class_Cloth.html">Cloth</a>.</p>

	<h3 class="t">Traits</h3>

	<ul>
		<li>Use PhysX classes as arguments or as a return value</li>
	</ul>

</div><h2 class="method function"><a name='getPhysXMeshData'></a>getPhysXMeshData</h2>
<div class="method">	<p class="c">Get the PhysXMeshData instance.</p>
	<p class="n"><b>Note</b> &#8212; This mesh is owned by the <a href="class_Cloth.html">Cloth</a>; do not delete the pointer.</p>
	<h3>Return</h3>

	<p class="r"><b>PhysXMeshData</b> * &#8212; PhysXMeshData used by the cloth.</p>

	<h3 class="s">See</h3>

	<p class="s">PhysXMeshData</p>

</div><h2 class="method function"><a name='getPosition'></a>getPosition</h2>
<div class="method">	<p class="c">Gets the position of a particular vertex of the cloth.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>unsigned int <i>vertexId</i> </td>
			<td> Index of the vertex</td>
		</tr>
	</table>

	<h3>Return</h3>

	<p class="r"><b>Vec3</b> &#8212; The vertex position.</p>

</div><h2 class="method function"><a name='getPositions'></a>getPositions</h2>
<div class="method">	<p class="c">Get the position for <em>all</em> of the particles at once.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>Buffer<Vec3>& <i>outPositions</i> </td>
			<td> Returns all the positions of the vertices as a Buffer of Vec3s.</td>
		</tr>
	</table>

</div><h2 class="method function"><a name='getPressure'></a>getPressure</h2>
<div class="method">	<p class="c">Retrieves the cloth pressure coefficient.</p>
	<h3>Return</h3>

	<p class="r"><b>Real</b> &#8212; Pressure coefficient</p>

</div><h2 class="method function"><a name='getRelativeGridSpacing'></a>getRelativeGridSpacing</h2>
<div class="method">	<p class="c">The cloth is represented by a set of world aligned cubical<br />cells in broad phase. The size of these cells is determined<br />by multiplying the length of the diagonal of the <span class="caps">AABB</span> of the<br />initial cloth size with this constant.</p>
	<h3>Return</h3>

	<p class="r"><b>Real</b> &#8212; Relative grid spacing</p>

</div><h2 class="method function"><a name='getRenderable'></a>getRenderable</h2>
<div class="method">	<p class="c">Get the renderable that the cloth is rendering to.</p>
	<h3>Return</h3>

	<p class="r"><b>Renderable</b> * &#8212; The renderable the cloth is rendering to.</p>

	<h3 class="s">See</h3>

	<p class="s">Renderable</p>

</div><h2 class="method function"><a name='getScene'></a>getScene</h2>
<div class="method">	<p class="c">Retrieves the scene which this cloth belongs to.</p>
	<h3>Return</h3>

	<p class="r"><b>Scene</b> * &#8212; The scene that the cloth belongs to.</p>

</div><h2 class="method functions"><a name='getSleepLinearVelocity'></a>getSleepLinearVelocity</h2>
<div class="method">	<p class="c">Returns the linear velocity below which a cloth may go to sleep.</p>
	<h3>Return</h3>

	<p class="r"><b>Real</b> &#8212; The linear velocity threshold of when the cloth will go to sleep.</p>

</div><h2 class="method function"><a name='getSolverIterations'></a>getSolverIterations</h2>
<div class="method">	<p class="c">Retrieves the cloth solver iterations.</p>
	<h3>Return</h3>

	<p class="r"><b>unsigned int</b> &#8212; <a href="class_Cloth.html">Cloth</a> solver iterations<br /><a href="class_Cloth.html">Cloth</a>::getSolverIterations</p>

</div><h2 class="method function"><a name='getStretchingStiffness'></a>getStretchingStiffness</h2>
<div class="method">	<p class="c">Gets the cloth stretching stiffness.</p>
	<h3>Return</h3>

	<p class="r"><b>Real</b> &#8212; Stretching stiffness</p>

	<h3 class="s">See</h3>

	<p class="s"><a href="class_Cloth.html">Cloth</a>::getStretchingStiffness</p>

</div><h2 class="method function"><a name='getTearFactor'></a>getTearFactor</h2>
<div class="method">	<p class="c">Retrieves the cloth tear factor.</p>
	<h3>Return</h3>

	<p class="r"><b>Real</b> &#8212; Tear factor.</p>

</div><h2 class="method function"><a name='getThickness'></a>getThickness</h2>
<div class="method">	<p class="c">Gets the cloth thickness.</p>
	<h3>Return</h3>

	<p class="r"><b>Real</b> &#8212; <a href="class_Cloth.html">Cloth</a> thickness</p>

	<h3 class="s">See</h3>

	<p class="s"><a href="class_Cloth.html">Cloth</a>::setThickness</p>

</div><h2 class="method function"><a name='getToFluidResponseCoefficient'></a>getToFluidResponseCoefficient</h2>
<div class="method">	<p class="c">Retrieves response coefficient for collisions from this cloth to fluids.</p>
	<h3>Return</h3>

	<p class="r"><b>Real</b> &#8212; response coefficient</p>

</div><h2 class="method functions"><a name='getValidBounds'></a>getValidBounds</h2>
<div class="method">	<p class="c">Gets the valid bounds.</p>
	<h3>Return</h3>

	<p class="r"><b>Bounds3</b> &#8212; The bounds.</p>

</div><h2 class="method function"><a name='getVelocities'></a>getVelocities</h2>
<div class="method">	<p class="c">Get the velocities for <em>all</em> of the particles at once.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>Buffer<Vec3>& <i>outVelocities</i> </td>
			<td> Returns all the velocities of the vertices as a Buffer of Vec3s.</td>
		</tr>
	</table>

</div><h2 class="method function"><a name='getVelocity'></a>getVelocity</h2>
<div class="method">	<p class="c">Gets the velocity of a particular vertex of the cloth.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>unsigned int <i>vertexId</i> </td>
			<td> Vertex index to apply the velocity to.</td>
		</tr>
	</table>

	<h3>Return</h3>

	<p class="r">Vec3 &#8212; Velocity of the vertex</p>

</div><h2 class="method function"><a name='getVertexAttachmentPosition'></a>getVertexAttachmentPosition</h2>
<div class="method">	<p class="c">Return the attachment position of the given vertex.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>unsigned int <i>vertexId</i> </td>
			<td> Index of the vertex.</td>
		</tr>
	</table>

	<h3>Return</h3>

	<p class="r"><b>Vec3</b> &#8212; Attachment position.</p>

</div><h2 class="method function"><a name='getVertexAttachmentShape'></a>getVertexAttachmentShape</h2>
<div class="method">	<p class="c">Returns the pointer to an attached shape pointer of the given vertex.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>unsigned int <i>vertexId</i> </td>
			<td> Index of the vertex.</td>
		</tr>
	</table>

	<h3>Return</h3>

	<p class="r"><b>Shape</b> * &#8212; Attachment status.</p>

</div><h2 class="method function"><a name='getVertexAttachmentStatus'></a>getVertexAttachmentStatus</h2>
<div class="method">	<p class="c">Return the attachment status of the given vertex.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>unsigned int <i>vertexId</i> </td>
			<td> Index of the vertex.</td>
		</tr>
	</table>

	<h3>Return</h3>

	<p class="r"><b>Enums::<a href="class_Cloth.html">Cloth</a>VertexAttachmentStatus</b> &#8212; Attachment status.</p>

</div><h2 class="method function"><a name='getWindAcceleration'></a>getWindAcceleration</h2>
<div class="method">	<p class="c">Retrieves the acceleration acting normal to the cloth surface at each vertex.</p>
	<h3>Return</h3>

	<p class="r"><b>Vec3</b> &#8212; The acceleration vector (<code>unit length / s^2</code>)</p>

</div><h2 class="method function"><a name='getWorldBounds'></a>getWorldBounds</h2>
<div class="method">	<p class="c">Returns a world space <span class="caps">AABB</span> enclosing all cloth points.</p>
	<h3>Return</h3>

	<p class="r"><b>Bounds3</b> &#8212; <a href="class_World.html">World</a> bounds</p>

</div><h2 class="method functions"><a name='isSleeping'></a>isSleeping</h2>
<div class="method">	<p class="c">Is the cloth sleeping?</p>
	<h3>Return</h3>

	<p class="r"><b>bool</b> &#8212; Returns true if this cloth is sleeping.</p>

</div><h2 class="method function"><a name='overlapAABBTriangles'></a>overlapAABBTriangles</h2>
<div class="method">	<p class="c">Finds triangles touching the input bounds.</p>
	<p class="n"><b>Note</b> &#8212; This method returns a pointer to an internal structure using the indices member. Hence theuser should use or copy the indices before calling any other <span class="caps">API</span> function.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>const Bounds3& <i>bounds</i> </td>
			<td> Bounds to test against in world space.</td>
		</tr>
		<tr>
			<td>unsigned int <i>nbIndices</i> </td>
			<td> Retrieves the number of triangle indices touching the <span class="caps">AABB</span></td>
		</tr>
		<tr>
			<td>const unsigned int*& <i>indicies</i> </td>
			<td> Returns an array of touching triangle indices.</td>
		</tr>
	</table>

	<h3>Return</h3>

	<p class="r"><b>bool</b> &#8212; True if there is an overlap.</p>

</div><h2 class="method function"><a name='putToSleep'></a>putToSleep</h2>
<div class="method">	<p class="c">Forces the cloth to sleep.</p>
</div><h2 class="method function"><a name='raycast'></a>raycast</h2>
<div class="method">	<p class="c">Executes a raycast against the cloth.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>const Ray& ray </td>
			<td> The ray in world space.</td>
		</tr>
	</table>

	<h3>Return</h3>

	<p class="r"><b><a href="class_Cloth.html">Cloth</a>RaycastHit</b> &#8212; Hit position and index to the vertex hit by the ray.</p>

</div><h2 class="method function"><a name='setAttachmentResponseCoefficient'></a>setAttachmentResponseCoefficient</h2>
<div class="method">	<p class="c">Sets the attachment response coefficient</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>Real <i>coefficient</i> </td>
			<td> Response coefficient; [0, 1].</td>
		</tr>
	</table>

</div><h2 class="method function"><a name='setAttachmentTearFactor'></a>setAttachmentTearFactor</h2>
<div class="method">	<p class="c">Sets the cloth attachment tear factor</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>Real <i>factor</i> </td>
			<td> attachment tear factor; (1, inf).</td>
		</tr>
	</table>

	<h3 class="s">See</h3>

	<p class="s"><a href="class_Cloth.html">Cloth</a>::getAttachmentTearFactor</p>

</div><h2 class="method function"><a name='setBendingStiffness'></a>setBendingStiffness</h2>
<div class="method">	<p class="c">Sets the cloth bending stiffness.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>Real <i>stiffness</i> </td>
			<td> Bending stiffness; [0, 1].</td>
		</tr>
	</table>

	<h3 class="s">See</h3>

	<p class="s"><a href="class_Cloth.html">Cloth</a>::getBendingStiffness</p>

</div><h2 class="method function"><a name='setCollisionResponseCoefficient'></a>setCollisionResponseCoefficient</h2>
<div class="method">	<p class="c">Sets the collision response coefficient.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>Real <i>coefficient</i> </td>
			<td> Collision response coefficient</td>
		</tr>
	</table>

</div><h2 class="method function"><a name='setDampingCoefficient'></a>setDampingCoefficient</h2>
<div class="method">	<p class="c">Sets the damping coefficient.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>Real <i>damping</i> </td>
			<td> Damping coefficent; [0..1].</td>
		</tr>
	</table>

</div><h2 class="method function"><a name='setExternalAcceleration'></a>setExternalAcceleration</h2>
<div class="method">	<p class="c">Sets an external acceleration (<code>unit length / s^2</code>) which affects all non attached particles of the cloth</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>const Vec3& <i>acceleration</i> </td>
			<td> The acceleration vector.</td>
		</tr>
	</table>

</div><h2 class="method function"><a name='setFlags'></a>setFlags</h2>
<div class="method">	<p class="c">Sets the flags, a combination of the bits defined by the enum Enums::<a href="class_Cloth.html">Cloth</a>Flags.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>unsigned int <i>flags</i> </td>
			<td> Combination of the Enums::ClothFlags using the <code>|</code> operator.</td>
		</tr>
	</table>

</div><h2 class="method function"><a name='setForceFieldMaterial'></a>setForceFieldMaterial</h2>
<div class="method">	<p class="c">Sets the actor&#8217;s force field material index</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>MaterialIdentifier <i>material</i> </td>
			<td> New forcefield material.</td>
		</tr>
	</table>

</div><h2 class="method function"><a name='setFriction'></a>setFriction</h2>
<div class="method">	<p class="c">Sets the cloth friction coefficient.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>Real <i>friction</i> </td>
			<td> Friction coefficient; [0 to 1].</td>
		</tr>
	</table>

	<h3 class="s">See</h3>

	<p class="s"><a href="class_Cloth.html">Cloth</a>::getFriction</p>

</div><h2 class="method function"><a name='setFromFluidResponseCoefficient'></a>setFromFluidResponseCoefficient</h2>
<div class="method">	<p class="c">Sets the response coefficient for collisions from fluids to this cloth</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>Real <i>coefficient</i> </td>
			<td> Response coefficient.</td>
		</tr>
	</table>

</div><h2 class="method function"><a name='setGroupsMask'></a>setGroupsMask</h2>
<div class="method">	<p class="c">Sets 128-bit mask used for collision filtering.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>const int4& <i>groupsMask</i> </td>
			<td> The group mask to set for the cloth.</td>
		</tr>
	</table>

</div><h2 class="method function"><a name='setMinAdhereVelocity'></a>setMinAdhereVelocity</h2>
<div class="method">	<p class="c">If the Enums::<a href="class_Cloth.html">Cloth</a>Flags_Adhere flag is set the cloth moves partially in the frame of the attached rigid body.</p>

	<p class="c">This feature is useful when the cloth is attached to a fast moving character.<br />In that case the cloth adheres to the shape it is attached to while only<br />velocities below the parameter minAdhereVelocity are used for secondary effects.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>Real <i>velocity</i> </td>
			<td> The minimal velocity for cloth to adhere (<code>unit length / s</code>)</td>
		</tr>
	</table>

	<h3 class="s">See</h3>

	<p class="s"><a href="class_Cloth.html">Cloth</a>::getMinAdhereVelocity</p>

</div><h2 class="method function"><a name='setName'></a>setName</h2>
<div class="method">	<p class="c">Sets a name string for the object that can be retrieved with <a href="class_Cloth.html">Cloth</a>::getName()</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>const String& <i>name</i> </td>
			<td> New name for the Cloth.</td>
		</tr>
	</table>

</div><h2 class="method function"><a name='setPosition'></a>setPosition</h2>
<div class="method">	<p class="c">Sets the position of a particular vertex of the cloth.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>const Vec3& <i>position</i> </td>
			<td> New position of the vertex</td>
		</tr>
		<tr>
			<td>unsigned int <i>vertexId</i> </td>
			<td> Index of the vertex</td>
		</tr>
	</table>

</div><h2 class="method function"><a name='setPositions'></a>setPositions</h2>
<div class="method">	<p class="c">Set the position for <em>all</em> of the particles at once.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>Buffer<Vec3>& <i>positions</i> </td>
			<td> All the new positions of the vertices as a Buffer of Vec3s.</td>
		</tr>
	</table>

</div><h2 class="method function"><a name='setPressure'></a>setPressure</h2>
<div class="method">	<p class="c">Sets the cloth pressure coefficient.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>Real <i>pressure</i> </td>
			<td>  Pressure coefficient; [0, inf).</td>
		</tr>
		<tr>
			<td>Cloth::getPressure</td>
		</tr>
	</table>

</div><h2 class="method functions"><a name='setSleepLinearVelocity'></a>setSleepLinearVelocity</h2>
<div class="method">	<p class="c">Returns the linear velocity below which a cloth may go to sleep.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>Real <i>threshold</i> </td>
			<td> The linear velocity threshold of when the cloth will go to sleep.</td>
		</tr>
	</table>

</div><h2 class="method function"><a name='setSolverIterations'></a>setSolverIterations</h2>
<div class="method">	<p class="c">Sets the cloth solver iterations.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>unsigned int <i>solverIterations</i> </td>
			<td> Number of iterations; (0, inf].</td>
		</tr>
		<tr>
			<td>Cloth::setSolverIterations</td>
		</tr>
	</table>

</div><h2 class="method function"><a name='setStretchingStiffness'></a>setStretchingStiffness</h2>
<div class="method">	<p class="c">Sets the cloth stretching stiffness in the range from 0 to 1.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>Real <i>stiffness</i> </td>
			<td> Stretching stiffness; (0, 1].</td>
		</tr>
	</table>

	<h3 class="s">See</h3>

	<p class="s"><a href="class_Cloth.html">Cloth</a>::setStretchingStiffness</p>

</div><h2 class="method function"><a name='setTearFactor'></a>setTearFactor</h2>
<div class="method">	<p class="c">Sets the cloth tear factor.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>Real <i>factor</i> </td>
			<td> Tear factor; (1, inf).</td>
		</tr>
	</table>

</div><h2 class="method function"><a name='setThickness'></a>setThickness</h2>
<div class="method">	<p class="c">Sets the cloth thickness.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>Real <i>thickness</i> </td>
			<td> Thickness; [0, inf).</td>
		</tr>
	</table>

	<h3 class="s">See</h3>

	<p class="s"><a href="class_Cloth.html">Cloth</a>::getThickness</p>

</div><h2 class="method function"><a name='setToFluidResponseCoefficient'></a>setToFluidResponseCoefficient</h2>
<div class="method">	<p class="c">Sets the response coefficient for collisions from this cloth to fluids</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>Real <i>coefficient</i> </td>
			<td> response coefficient</td>
		</tr>
	</table>

</div><h2 class="method functions"><a name='setValidBounds'></a>setValidBounds</h2>
<div class="method">	<p class="c">Sets the valid bounds of the cloth in world space.</p>

	<p class="c">If the flag Enums::<a href="class_Cloth.html">Cloth</a>Flags_ValidBounds is set, these bounds defines the volume<br />outside of which cloth particle are automatically removed from the simulation.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>const Bounds3& <i>bounds</i> </td>
			<td> Valid bounds.</td>
		</tr>
	</table>

</div><h2 class="method function"><a name='setVelocities'></a>setVelocities</h2>
<div class="method">	<p class="c">Set the velocities of all the vertices at once.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>Buffer<Vec3>& <i>velocities</i> </td>
			<td> All the new velocities of the vertices as a Buffer of Vec3s.</td>
		</tr>
	</table>

</div><h2 class="method function"><a name='setVelocity'></a>setVelocity</h2>
<div class="method">	<p class="c">Sets the velocity of a particular vertex of the cloth.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>const Vec3& <i>velocity</i> </td>
			<td> New velocity of the vertex</td>
		</tr>
		<tr>
			<td>unsigned int <i>vertexId</i> </td>
			<td> Vertex index to apply the velocity to.</td>
		</tr>
	</table>

</div><h2 class="method function"><a name='setWindAcceleration'></a>setWindAcceleration</h2>
<div class="method">	<p class="c">Sets an acceleration acting normal to the cloth surface at each vertex.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>const Vec3& <i>acceleration</i> </td>
			<td> The acceleration vector (<code>unit length / s^2</code>)</td>
		</tr>
	</table>

</div><h2 class="method function"><a name='tearVertex'></a>tearVertex</h2>
<div class="method">	<p class="c">First the vertex is duplicated. The triangles on one side of the split plane keep<br />the original vertex. For all triangles on the opposite side the original vertex is<br />replaced by the new one. The split plane is defined by the world location of the<br />vertex and the normal provided by the user.</p>
	<p class="n"><b>Note</b> &#8212; * TearVertex performs a user defined vertex split in contrast to an automatic split<br />that is performed when the flag Enums::<a href="class_Cloth.html">Cloth</a>AttachmentFlags_Tearable is set.<br />Therefore, tearVertex works even if Enums::<a href="class_Cloth.html">Cloth</a>AttachmentFlags_Tearable is not<br />set in <a href="class_Cloth.html">Cloth</a>Description::mFlags.
	<ul>
		<li>For tearVertex to work, the clothMesh has to be cooked with the flag</li>
	</ul><br />Enums::<a href="class_Cloth.html">Cloth</a>AttachmentFlags_Tearable set in NxClothMeshDesc.flags.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>const unsigned int <i>vertexId</i> </td>
			<td> Index of the vertex.</td>
		</tr>
		<tr>
			<td>const Vec3& <i>normal</i> </td>
			<td>  The normal of the split plane.</td>
		</tr>
	</table>

	<h3>Return</h3>

	<p class="r"><b>bool</b> &#8212; True if the split had an effect</p>

</div><h2 class="method function"><a name='wakeUp'></a>wakeUp</h2>
<div class="method">	<p class="c">Wakes up the cloth if it is sleeping.</p>
	<h3>Arguments</h3>

	<table>
		<tr>
			<th>Argument</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>Real <i>wakeCounterValue</i> </td>
			<td> New sleep counter value; [0, inf]</td>
		</tr>
	</table>

</div>
      </div>
  	</div>
	<div id="F"></div>
</div>
</body>
</html>